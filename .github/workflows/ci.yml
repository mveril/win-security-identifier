name: Rust CI

on:
  push:
    branches: [main, develop, 'release/*']
  pull_request:
    branches: [main, develop, 'release/*']
  schedule:
    - cron: '0 3 * * 0'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build-test-std:
    name: Build & test (${{ matrix.os }}, ${{ matrix.toolchain }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        toolchain: [stable, nightly]
    env:
      CARGO_TERM_COLOR: always
      RUSTFLAGS: -D warnings
      RUSTDOCFLAGS: -D warnings
      CARGO_INCREMENTAL: 0

    steps:
      - uses: actions/checkout@v4
      - name: Set up Rust toolchain (${{ matrix.toolchain }})
        run: |
          rustup set profile minimal
          rustup update ${{ matrix.toolchain }}
          rustup default ${{ matrix.toolchain }}
          rustup component add rustfmt clippy
      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/advisory-db
            target
          key: ${{ runner.os }}-cargo-${{ matrix.toolchain }}-${{ hashFiles('**/Cargo.toml') }}
      - run: rustc -Vv && cargo -V
      - if: ${{ matrix.os == 'ubuntu-latest' && matrix.toolchain == 'nightly' }}
        run: cargo install --locked cargo-audit || echo "cargo-audit already installed"
      - if: ${{ matrix.os == 'ubuntu-latest' && matrix.toolchain == 'nightly' }}
        run: cargo audit
      - run: cargo fmt --all -- --check
      - run: cargo clippy --workspace --all-targets --all-features -- -D warnings
      - run: cargo build --workspace --all-features
      - run: cargo test --workspace --all-features --all-targets -- --nocapture

  no-std:
    name: no_std (Nu detect core/alloc → build)
    runs-on: ubuntu-latest
    env:
      CARGO_TERM_COLOR: always
      RUSTFLAGS: -D warnings
      RUSTDOCFLAGS: -D warnings
      CARGO_INCREMENTAL: 0

    steps:
      - uses: actions/checkout@v4
      - uses: hustcer/setup-nu@v3
        with:
          version: '0.108.0'
      - name: Toolchain + bare-metal target
        run: |
          rustup set profile minimal
          rustup update stable
          rustup default stable
          rustup target add x86_64-unknown-none

      - name: detect-core-alloc (Nu → files)
        shell: nu {0}
        run: |
          # Base dirs and metadata
          let base = ($env.RUNNER_TEMP | path join 'ci')
          mkdir $base | ignore
          let target_bare = "x86_64-unknown-none"

          let meta = (cargo metadata --no-deps --format-version=1 | from json)

          # Workspace members (IDs) → join back to `packages` by id
          let members = $meta.workspace_members
          let pkgs_ws = (
            $meta.packages
            | where {|p| $members | any {|m| $m == $p.id}}
          )

          # Keep packages that are NOT "proc-macro only"
          let pkgs_liblike = (
            $pkgs_ws
            | where {|p|
                not (
                  $p.targets | all {|t| $t.kind | any {|k| $k == 'proc-macro'}}
                )
              }
            | select id name features targets
            | sort-by name
          )

          # Debug: kinds seen & selection
          ($pkgs_ws
            | select name targets
            | each {|p| { name: $p.name, kinds: ($p.targets | each {|t| $t.kind} | flatten | uniq | sort) }}
          ) | to json | save --force ($base | path join 'targets_seen.json')

          ($pkgs_liblike | select id name | to json) | save --force ($base | path join 'selected_ws_liblike.json')

          # Helper: extras = all features except default/std/alloc
          def to_extras [feat_map] {
            let keys = (if ($feat_map == null) { [] } else { $feat_map | columns })
            let extras = ($keys | where {|f| $f != 'default' and $f != 'std' and $f != 'alloc'} | sort | str join ',')
            if ($extras | is-empty) { '' } else { $extras }
          }

          # Build matrices from the same base
          mut core_matrix = []
          mut alloc_matrix = []

          for p in $pkgs_liblike {
            let extras = (to_extras $p.features)
            let core_args = if ($extras == '') { '--no-default-features' } else { $"--no-default-features --features ($extras)" }
            $core_matrix = ($core_matrix | append { pkg: $p.name, args: $core_args })

            let keys = (if ($p.features == null) { [] } else { $p.features | columns })
            if ($keys | any {|f| $f == 'alloc'}) {
              let alloc_args = if ($extras == '') { '--no-default-features --features alloc' } else { $"--no-default-features --features alloc,($extras)" }
              $alloc_matrix = ($alloc_matrix | append { pkg: $p.name, args: $alloc_args })
            }
          }

          # Persist
          $target_bare | save --force ($base | path join 'target_bare.txt')
          ($core_matrix  | to json) | save --force ($base | path join 'core_matrix.json')
          ($alloc_matrix | to json) | save --force ($base | path join 'alloc_matrix.json')

          # Immediate dump for visibility
          print '== WORKSPACE MEMBERS (ids) =='
          $members | each {|m| print $"- ($m)"} | ignore

          print '== SELECTED LIB-LIKE PACKAGES =='
          ($pkgs_liblike | get name | each {|n| print $"- ($n)"} | ignore)

          print 'CORE_MATRIX (built now):'
          if ($core_matrix | is-empty) { print '(empty)' } else { $core_matrix | table }

          print 'ALLOC_MATRIX (built now):'
          if ($alloc_matrix | is-empty) { print '(empty)' } else { $alloc_matrix | table }

          # Sanity check: ensure parsing appears in CORE
          let core_names = ($core_matrix | get pkg | default [])
          if (not ($core_names | any {|n| $n == 'win-security-identifier-parsing'})) {
            print 'ERR: parsing missing from CORE_MATRIX → forcing inclusion.'
            $core_matrix = ($core_matrix | append { pkg: 'win-security-identifier-parsing', args: '--no-default-features' })
            ($core_matrix | to json) | save --force ($base | path join 'core_matrix.json')
          }

          if (($core_matrix | is-empty) and ($alloc_matrix | is-empty)) { print 'FATAL: Both CORE_MATRIX and ALLOC_MATRIX are empty.'; exit 1 }

      - name: Debug matrices (Nu)
        if: always()
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')

          print 'TARGET KINDS SEEN:'
          if ($base | path join 'targets_seen.json' | path exists) { open ($base | path join 'targets_seen.json') | table } else { print '(missing targets_seen.json)' }

          print 'SELECTED LIB-LIKE PACKAGES:'
          if ($base | path join 'selected_ws_liblike.json' | path exists) { open ($base | path join 'selected_ws_liblike.json') | table } else { print '(missing selected_ws_liblike.json)' }

          print 'CORE_MATRIX:'
          if ($base | path join 'core_matrix.json' | path exists) { let cm = open ($base | path join 'core_matrix.json'); if ($cm | is-empty) { print '(empty)' } else { $cm | table } } else { print '(missing)' }

          print 'ALLOC_MATRIX:'
          if ($base | path join 'alloc_matrix.json' | path exists) { let am = open ($base | path join 'alloc_matrix.json'); if ($am | is-empty) { print '(empty)' } else { $am | table } } else { print '(missing)' }

      - name: Cargo check (no_std) [Nu]
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')
          let TARGET = (open --raw ($base | path join 'target_bare.txt') | str trim)

          let core = (if ($base | path join 'core_matrix.json' | path exists) { open ($base | path join 'core_matrix.json') } else { [] })
          let alloc = (if ($base | path join 'alloc_matrix.json' | path exists) { open ($base | path join 'alloc_matrix.json') } else { [] })
          let final = ($core | append $alloc)

          if ($final | is-empty) { print 'No no_std rows. Failing for visibility.'; exit 1 }

          for row in $final {
            let pkg = $row.pkg
            let args = ($row.args | split row ' ')
            print $">> check: ($pkg) @ ($TARGET) [$row.args]"
            ^cargo check -p $pkg --target $TARGET ...$args
          }

      - name: Cargo build (no_std, release) [Nu]
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')
          let TARGET = (open --raw ($base | path join 'target_bare.txt') | str trim)

          let core = (if ($base | path join 'core_matrix.json' | path exists) { open ($base | path join 'core_matrix.json') } else { [] })
          let alloc = (if ($base | path join 'alloc_matrix.json' | path exists) { open ($base | path join 'alloc_matrix.json') } else { [] })
          let final = ($core | append $alloc)

          for row in $final {
            let pkg = $row.pkg
            let args = ($row.args | split row ' ')
            print $">> build: ($pkg) @ ($TARGET) [$row.args]"
            ^cargo build -p $pkg --release --target $TARGET ...$args
          }
