name: Rust CI

on:
  push:
    branches: [main, develop, 'release/*']
  pull_request:
    branches: [main, develop, 'release/*']
  schedule:
    - cron: '0 3 * * 0'  # weekly audit

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  # ============================================================
  # 1) std job: audit • fmt • clippy • build • test
  # ============================================================
  build-test-std:
    name: Build & test (${{ matrix.os }}, ${{ matrix.toolchain }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        toolchain: [stable, nightly]
    env:
      CARGO_TERM_COLOR: always
      RUSTFLAGS: -D warnings
      RUSTDOCFLAGS: -D warnings
      CARGO_INCREMENTAL: 0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Rust toolchain (${{ matrix.toolchain }})
        run: |
          set -euxo pipefail
          rustup set profile minimal
          rustup update ${{ matrix.toolchain }}
          rustup default ${{ matrix.toolchain }}
          rustup component add rustfmt clippy

      - name: Cache cargo registries, target and advisory DB
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/advisory-db
            target
          key: ${{ runner.os }}-cargo-${{ matrix.toolchain }}-${{ hashFiles('**/Cargo.toml') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.toolchain }}-
            ${{ runner.os }}-cargo-

      - name: Show Rust versions
        run: |
          set -euxo pipefail
          rustc -Vv
          cargo -V

      - name: Install cargo-audit (ubuntu-nightly only)
        if: ${{ matrix.os == 'ubuntu-latest' && matrix.toolchain == 'nightly' }}
        run: |
          set -euxo pipefail
          cargo install --locked cargo-audit || echo "cargo-audit already installed"

      - name: Run cargo audit (ubuntu-nightly only)
        if: ${{ matrix.os == 'ubuntu-latest' && matrix.toolchain == 'nightly' }}
        run: |
          set -euxo pipefail
          cargo audit

      - name: Check code format
        run: |
          set -euxo pipefail
          cargo fmt --all -- --check

      - name: Run Clippy (deny warnings)
        run: |
          set -euxo pipefail
          cargo clippy --workspace --all-targets --all-features -- -D warnings

      - name: Build workspace
        run: |
          set -euxo pipefail
          cargo build --workspace --all-features

      - name: Run tests
        run: |
          set -euxo pipefail
          cargo test --workspace --all-features --all-targets -- --nocapture


  # ============================================================
  # 2) no_std job: detect (Nu) + compile (core & alloc) with solid outputs
  # ============================================================
  no-std:
    name: no_std (Nu detect core/alloc → build)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
    
      # Pin Nu for reproducibility
      - name: Setup Nushell
        uses: hustcer/setup-nu@v3
        with:
          version: '0.108.0'
        
      - name: Toolchain + no_std target
        shell: bash
        run: |
          set -euxo pipefail
          rustup set profile minimal
          rustup update stable
          rustup default stable
          rustup target add x86_64-unknown-none
        
      # ----------------------------------------------------------
      # detect-nostd (Nu → files in $RUNNER_TEMP/ci)
      # - Finds workspace lib packages
      # - CORE: --no-default-features + all non-[default,std,alloc] features
      # - Writes:
      #     $RUNNER_TEMP/ci/target_bare.txt
      #     $RUNNER_TEMP/ci/pkg_list.json
      #     $RUNNER_TEMP/ci/core_matrix.json
      # ----------------------------------------------------------
      - name: detect-nostd (Nu → files)
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')
          mkdir $base | ignore
      
          let target_bare = "x86_64-unknown-none"
          let meta     = (cargo metadata --no-deps --format-version=1 | from json)
          let members  = $meta.workspace_members
          let lib_kinds = [lib rlib staticlib cdylib dylib]
      
          # Collect workspace packages that expose at least one library-like target
          let pkgs = (
            $meta.packages
            | where {|p| $members | any {|m| $m == $p.id } }
            | where {|p|
                $p.targets
                | any {|t|
                    ($t.kind? | default [])
                    | any {|k| $lib_kinds | any {|lk| $lk == $k } }
                  }
              }
            | get name
            | uniq
          )
      
          # Build core matrix per package
          mut core_matrix = []
          for name in $pkgs {
            let pkg        = ($meta.packages | where name == $name | first)
            let feat_cols  = (($pkg.features? | default {}) | columns)
            let extra      = (
              $feat_cols
              | where {|f| $f != "default" and $f != "std" and $f != "alloc"}
              | str join ","
            )
            let args = if ($extra | is-empty) {
              "--no-default-features"
            } else {
              $"--no-default-features --features ($extra)"
            }
            $core_matrix = ($core_matrix | append { pkg: $name, args: $args })
          }
      
          # Write working files
          $"($target_bare)"                 | save --force ($base | path join 'target_bare.txt')
          ($pkgs        | to json --raw)    | save --force ($base | path join 'pkg_list.json')
          ($core_matrix | to json --raw)    | save --force ($base | path join 'core_matrix.json')
      
          # Human log
          print "== no_std candidates (lib targets) =="
          ($pkgs | each {|n| print $"- ($n)"} | ignore)
          print $"core_matrix size: ($core_matrix | length)"
      
      # ----------------------------------------------------------
      # detect-alloc (Nu → file)
      # - For packages that define an "alloc" feature, produce an alloc matrix:
      #     --no-default-features --features alloc[,extras...]
      # - Writes:
      #     $RUNNER_TEMP/ci/alloc_matrix.json
      # ----------------------------------------------------------
      - name: detect-alloc (Nu → files)
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')
          let meta = (cargo metadata --no-deps --format-version=1 | from json)
          let pkgs = (open ($base | path join 'pkg_list.json') | from json)
      
          mut alloc_matrix = []
          for name in $pkgs {
            let pkg       = ($meta.packages | where name == $name | first)
            let feat_cols = (($pkg.features? | default {}) | columns)
            if ($feat_cols | any {|f| $f == "alloc"}) {
              let extra = (
                $feat_cols
                | where {|f| $f != "default" and $f != "std" and $f != "alloc"}
                | str join ","
              )
              let args = if ($extra | is-empty) {
                "--no-default-features --features alloc"
              } else {
                $"--no-default-features --features alloc,($extra)"
              }
              $alloc_matrix = ($alloc_matrix | append { pkg: $name, args: $args })
            }
          }
      
          ($alloc_matrix | to json --raw) | save --force ($base | path join 'alloc_matrix.json')
          print $"alloc_matrix size: ($alloc_matrix | length)"
      
      # ----------------------------------------------------------
      # Optional debug: pretty print what will be consumed
      # ----------------------------------------------------------
      - name: Debug matrices (Nu)
        if: always()
        shell: nu {0}
        run: |
          let base = ($env.RUNNER_TEMP | path join 'ci')
          print "CORE_MATRIX:"
          (open ($base | path join 'core_matrix.json') | from json) | table
          print "ALLOC_MATRIX:"
          if (path exists ($base | path join 'alloc_matrix.json')) {
            (open ($base | path join 'alloc_matrix.json') | from json) | table
          } else {
            [] | table
          }
      
      # ----------------------------------------------------------
      # Build/check using the matrices read from files
      # ----------------------------------------------------------
      - name: Cargo check (no_std) [Nu]
        shell: nu {0}
        run: |
          let base   = ($env.RUNNER_TEMP | path join 'ci')
          let TARGET = (open ($base | path join 'target_bare.txt') | decode utf-8 | str trim)
          let core   = (open ($base | path join 'core_matrix.json')  | from json)
          let alloc  = (if (path exists ($base | path join 'alloc_matrix.json')) { open ($base | path join 'alloc_matrix.json') | from json } else { [] })
          let final  = ($core | append $alloc)
      
          if ($final | is-empty) {
            print "No no_std rows. Failing for visibility."
            exit 1
          }
      
          for row in $final {
            let pkg  = $row.pkg
            let args = ($row.args | split row ' ')
            print $">> check: ($pkg) @ ($TARGET)  [$row.args]"
            ^cargo check -p $pkg --target $TARGET ...$args
          }
      
      - name: Cargo build (no_std, release) [Nu]
        shell: nu {0}
        run: |
          let base   = ($env.RUNNER_TEMP | path join 'ci')
          let TARGET = (open ($base | path join 'target_bare.txt') | decode utf-8 | str trim)
          let core   = (open ($base | path join 'core_matrix.json')  | from json)
          let alloc  = (if (path exists ($base | path join 'alloc_matrix.json')) { open ($base | path join 'alloc_matrix.json') | from json } else { [] })
          let final  = ($core | append $alloc)
      
          for row in $final {
            let pkg  = $row.pkg
            let args = ($row.args | split row ' ')
            print $">> build: ($pkg) @ ($TARGET)  [$row.args]"
            ^cargo build -p $pkg --release --target $TARGET ...$args
          }
      